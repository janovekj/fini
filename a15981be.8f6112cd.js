(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{70:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(2),i=n(6),r=(n(0),n(76)),s={title:"Event Handlers and Transitions"},o={unversionedId:"essentials/event-handlers-and-transitions",id:"essentials/event-handlers-and-transitions",isDocsHomePage:!1,title:"Event Handlers and Transitions",description:"State machines are all about responding to events and transitioning to new states. In Fini, this should feel effortless.",source:"@site/docs/essentials/event-handlers-and-transitions.md",slug:"/essentials/event-handlers-and-transitions",permalink:"/essentials/event-handlers-and-transitions",editUrl:"https://github.com/janovekj/fini/edit/master/site/docs/essentials/event-handlers-and-transitions.md",version:"current",sidebar:"docs",previous:{title:"Schema Definition",permalink:"/essentials/schema-definition"},next:{title:"The Machine Object",permalink:"/essentials/the-machine-object"}},c=[{value:"Changing states",id:"changing-states",children:[]},{value:"Updating context",id:"updating-context",children:[]},{value:"Event payloads",id:"event-payloads",children:[]},{value:"Executing side-effects",id:"executing-side-effects",children:[]},{value:"Life cycle effects",id:"life-cycle-effects",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"State machines are all about responding to events and transitioning to new states. In Fini, this should feel effortless."),Object(r.b)("h2",{id:"changing-states"},"Changing states"),Object(r.b)("p",null,"There's different ways to transition between states, so let's get a quick overview. The next example shows all the possible ways of expressing a transition from ",Object(r.b)("inlineCode",{parentName:"p"},"state1")," to ",Object(r.b)("inlineCode",{parentName:"p"},"state2"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'useMachine({\n  state1: {\n    // String shorthand\n    event1: "state2",\n\n    // Update object\n    event2: {\n      state: "state2"\n    }\n\n    // String shorthand returned from event handler function\n    event3: () => "state2",\n\n    // Update object returned from event handler function\n    event4: () => ({\n      state: "state2"\n    })\n  },\n  state2: {}\n})\n')),Object(r.b)("p",null,"The first two methods are fine for transitions where no logic is involved, but for everything else, you'll probably want to use a function."),Object(r.b)("p",null,"Note: the event handler function should be ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Pure_function"}),"pure"),". If you need to perform side-effects, we'll talk about that in just a minute."),Object(r.b)("h2",{id:"updating-context"},"Updating context"),Object(r.b)("p",null,"Handling an event will often include some changes to the context. Fini has a couple of ways to achieve this as well."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'type M = Machine<\n  {\n    state1: State<{\n      event1: never;\n      event2: never;\n      event3: never;\n      event4: never;\n    }>;\n  },\n  {\n    contextProperty: string;\n  }\n>;\n\nuseMachine({\n  state1: {\n    // Context update object\n    // Current state stays the same\n    event1: {\n      contextProperty: "some value",\n    },\n\n    // Update object\n    event2: {\n      state: "state1",\n      context: {\n        contextProperty: "some value",\n      },\n    },\n\n    // Context update object returned from event handler function\n    event3: () => ({\n      contextProperty: "some value",\n    }),\n\n    // Update object returned from event handler function\n    event4: () => ({\n      state: "state1",\n      context: {\n        contextProperty: "some value",\n      },\n    }),\n  },\n});\n')),Object(r.b)("p",null,"This is pretty similar to how changing state works. It's worth noting that ",Object(r.b)("inlineCode",{parentName:"p"},"event1")," and ",Object(r.b)("inlineCode",{parentName:"p"},"event3")," just returns the new context directly, and since the object doesn't include a ",Object(r.b)("inlineCode",{parentName:"p"},"state")," property, Fini will assume that this is a context update."),Object(r.b)("p",null,"All event handler functions also receive the current context and state name as the first parameter:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"useMachine({\n  counting: {\n    increment: ({ state, context }) => ({\n      count: context.count + 1,\n    }),\n  },\n});\n")),Object(r.b)("p",null,"Updating the context works the same way you normally update state in reducer functions: you have to return the entire context object, not just the properties you're updating. If the state you're transitioning to has its own context properties, you must also make sure that the returned context is compatible with this new shape."),Object(r.b)("p",null,"It's also completely fine to not return nothing at all. This is often the case if you just want to run some side-effects, which we'll talk about later! If nothing is returned, nothing will be updated."),Object(r.b)("h2",{id:"event-payloads"},"Event payloads"),Object(r.b)("p",null,"A state machine would be quite useless if we couldn't pass along data with the events we're dispatching. If the event supports a payload, this is the second parameter passed into the event handler function:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type CounterMachine = Machine<\n  {\n    counting: {\n      setCount: number;\n    };\n  },\n  {\n    count: number;\n  }\n>;\n\nuseMachine({\n  counting: {\n    setCount: ({ context }, newCount) => ({\n      count: newCount,\n    }),\n  },\n});\n")),Object(r.b)("h2",{id:"executing-side-effects"},"Executing side-effects"),Object(r.b)("p",null,"Event handler functions should be pure, so side-effects must be handled on Fini's terms. Luckily, this is also trivial. Alongside the ",Object(r.b)("inlineCode",{parentName:"p"},"context")," property, the ",Object(r.b)("inlineCode",{parentName:"p"},"exec")," function is also passed into the event handler function. You can use ",Object(r.b)("inlineCode",{parentName:"p"},"exec")," to safely fire away any and all side-effects."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'useMachine({\n  idle: {\n    login: ({ context, exec }, userId) => {\n      // highlight-start\n      exec(() => {\n        fetchUser(userId).then((user) => console.log(user));\n      });\n      // highlight-end\n      return "fetchingUser";\n    },\n  },\n  fetchingUser: {},\n});\n')),Object(r.b)("p",null,"As you can see, ",Object(r.b)("inlineCode",{parentName:"p"},"exec")," accepts a function that triggers the side-effects. The function passed into ",Object(r.b)("inlineCode",{parentName:"p"},"exec")," also receives a dispatcher you can use to dispatch events from your side-effect, like in the example below:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'useMachine({\n  idle: {\n    login: ({ context, exec }, userId) => {\n      // highlight-start\n      exec((dispatch) => {\n        fetchUser(userId).then((user) => dispatch.success(user));\n      });\n      // highlight-end\n      return "fetchingUser";\n    },\n  },\n  fetchingUser: {\n    success: ({ context }, user) => ({\n      ...context,\n      user,\n    }),\n  },\n});\n')),Object(r.b)("h2",{id:"life-cycle-effects"},"Life cycle effects"),Object(r.b)("p",null,"Sometimes you'll want to define effects that should run every time a state is entered or exited. Fini allows you to achieve this by specifying the special ",Object(r.b)("inlineCode",{parentName:"p"},"$entry")," and ",Object(r.b)("inlineCode",{parentName:"p"},"$exit")," events, respectively."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'useMachine(\n  {\n    state1: {\n      // will be run every time `state1` is entered\n      // is also run if state is the initial state\n      $entry: () => console.log("Entered state1"),\n\n      // will be run every time `state1` is exited\n      $exit: () => console.log("Exited state1"),\n    },\n  },\n  "state1"\n);\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"$entry")," and ",Object(r.b)("inlineCode",{parentName:"p"},"$exit")," are pretty similar to regular event handler functions, except they don't return a new state. They are only for running effects, which is also why you don't need to wrap them in the ",Object(r.b)("inlineCode",{parentName:"p"},"exec")," function - Fini will do that for you behind the scenes."),Object(r.b)("p",null,"Both functions also receive an object containing the current ",Object(r.b)("inlineCode",{parentName:"p"},"state"),", ",Object(r.b)("inlineCode",{parentName:"p"},"context")," and the ",Object(r.b)("inlineCode",{parentName:"p"},"dispatch")," function. Additionally, ",Object(r.b)("inlineCode",{parentName:"p"},"$entry")," receives ",Object(r.b)("inlineCode",{parentName:"p"},"previousState"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"$exit")," receieves ",Object(r.b)("inlineCode",{parentName:"p"},"nextState"),"."))}u.isMDXComponent=!0},76:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=a,h=p["".concat(s,".").concat(b)]||p[b]||d[b]||r;return n?i.a.createElement(h,o(o({ref:t},l),{},{components:n})):i.a.createElement(h,o({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=b;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return i.a.createElement.apply(null,s)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);