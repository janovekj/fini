(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{60:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return p}));var a=t(2),i=t(6),s=(t(0),t(73)),o={id:"step-by-step-tutorial",title:"Step-by-step tutorial",sidebar_label:"Step-by-step tutorial",slug:"/"},c={unversionedId:"step-by-step-tutorial",id:"step-by-step-tutorial",isDocsHomePage:!1,title:"Step-by-step tutorial",description:"Creating stuff is the best way to showcase Fini's features, so let's do exactly that. We'll build a state machine step-by-step to support a simple login sequence.",source:"@site/docs/step-by-step-tutorial.md",slug:"/",permalink:"/fini/",editUrl:"https://github.com/janovekj/fini/edit/gh-pages/website/docs/step-by-step-tutorial.md",version:"current",sidebar_label:"Step-by-step tutorial",sidebar:"docs",next:{title:"Powered by MDX",permalink:"/fini/mdx"}},l=[{value:"Defining the schema",id:"defining-the-schema",children:[]},{value:"Implementing a basic machine",id:"implementing-a-basic-machine",children:[]},{value:"States and side-effects",id:"states-and-side-effects",children:[]},{value:"Finished result",id:"finished-result",children:[]},{value:"Admonitions",id:"admonitions",children:[]}],r={rightToc:l};function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},r,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Creating stuff is the best way to showcase Fini's features, so let's do exactly that. We'll build a state machine step-by-step to support a simple login sequence."),Object(s.b)("h2",{id:"defining-the-schema"},"Defining the schema"),Object(s.b)("p",null,"Fini encourages type safety by defining fully typed schemas for your machines. As such, it exposes some helpers for defining these types."),Object(s.b)("p",null,"The first type we'll look at, is the ",Object(s.b)("inlineCode",{parentName:"p"},"Machine")," type. It isn't very interesting on its own - it's simply sort of a wrapper for everything else."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import { Machine } from "fini";\n\ntype LoginMachine = Machine;\n')),Object(s.b)("p",null,"Not very exciting. Let's add a state by using the ",Object(s.b)("inlineCode",{parentName:"p"},"State")," helper type. We'll start simple by only adding the ",Object(s.b)("inlineCode",{parentName:"p"},"input")," state - the state where we await the user's credentials."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import { Machine, State } from "fini";\n\ntype LoginMachine = Machine<{\n  input: State;\n}>;\n')),Object(s.b)("p",null,"As you can see, ",Object(s.b)("inlineCode",{parentName:"p"},"Machine")," accepts a type argument: an object type where we can define our states."),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"State")," type also accepts a type argument like this, but instead it's a map for the events it should handle. Let's add one!"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import { Machine, State } from "fini";\n\ntype LoginMachine = Machine<{\n  input: State<{\n    // highlight-next-line\n    changeEmail: string;\n  }>;\n}>;\n')),Object(s.b)("p",null,"Each event name is mapped to a corresponding ",Object(s.b)("em",{parentName:"p"},"payload type"),". This refers to the data that we might want to pass along with the event. In our case, we're sending an email address, which is a ",Object(s.b)("inlineCode",{parentName:"p"},"string"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"changeEmail")," is typed accordingly."),Object(s.b)("p",null,"If you're coming from Redux, it's pretty much the exact same as the concept of payloads in action objects (because behind the scenes, this ",Object(s.b)("em",{parentName:"p"},"is")," an action object - Fini just calls them events instead)."),Object(s.b)("p",null,"Anyways, we'll need an event to handle password input as well."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type LoginMachine = Machine<{\n  input: State<{\n    changeEmail: string;\n    changePassword: string;\n  }>;\n}>;\n")),Object(s.b)("p",null,"There's no point to handling all these changes if we can't actually ",Object(s.b)("em",{parentName:"p"},"save")," the data. That is, we'll need to actually specify that our ",Object(s.b)("inlineCode",{parentName:"p"},"LoginMachine")," operates with a ",Object(s.b)("em",{parentName:"p"},"context"),", where we'll keep the password and email."),Object(s.b)("p",null,"We can define such a context in two ways:\n",Object(s.b)("strong",{parentName:"p"},"1. For the specific state(s) where the data are available")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type LoginMachine = Machine<{\n  input: State<\n    {\n      changeEmail: string;\n      changePassword: string;\n    },\n    // Defined inside the `State`\n    { email: string; password: string }\n  >;\n}>;\n")),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},'2. "Globally" for the entire machine')),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n    }>;\n  },\n  // Defined inside the `Machine`\n  { email: string; password: string }\n>;\n")),Object(s.b)("p",null,"If the same properties are defined both globally and for a state, Fini will prefer the state-specific context, ",Object(s.b)("em",{parentName:"p"},"if")," the machine is currently in that state."),Object(s.b)("p",null,"In our case, we'll use email and password throughout most of the state, so we'll just define it for the entire machine (the second method)."),Object(s.b)("p",null,"To put everything we have covered so far into context, let's actually just start working on implementing the machine."),Object(s.b)("h2",{id:"implementing-a-basic-machine"},"Implementing a basic machine"),Object(s.b)("p",null,"We'll import the ",Object(s.b)("inlineCode",{parentName:"p"},"useMachine")," hook, and give it ",Object(s.b)("inlineCode",{parentName:"p"},"LoginMachine")," as a type argument, and an empty object which we'll expand shortly:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import { Machine, State, useMachine } from "fini";\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n    }>;\n  },\n  { email: string; password: string }\n>;\n\nconst LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>({});\n};\n')),Object(s.b)("p",null,"To keep TypeScript from complaining too much, I also like to provide the initial values right away:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {},\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"Tip: If it weren't for ",Object(s.b)("inlineCode",{parentName:"p"},"email")," and ",Object(s.b)("inlineCode",{parentName:"p"},"password")," being required, we could just have passed in ",Object(s.b)("inlineCode",{parentName:"p"},'"input"')," as a shorthand, instead of an entire object."),Object(s.b)("p",null,"Next we'll add the ",Object(s.b)("inlineCode",{parentName:"p"},"input")," state and the ",Object(s.b)("inlineCode",{parentName:"p"},"changeEmail")," event handler:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: (machine, payload) => ({\n        state: "input",\n        context: {\n          ...machine.context,\n          email: payload,\n        },\n      }),\n    },\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"As you can see, ",Object(s.b)("inlineCode",{parentName:"p"},"changeEmail")," accepts a function where two parameters are provided:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},Object(s.b)("inlineCode",{parentName:"li"},"machine")," is an object containing the current context, as well as some other things that we'll cover later"),Object(s.b)("li",{parentName:"ol"},Object(s.b)("inlineCode",{parentName:"li"},"payload"),", which is the value being passed along with the event. It is of the same type as the one defined on the state's event in our schema")),Object(s.b)("p",null,"The purpose of the function is to return the next state. In our case, we're not actually going into a new state - we're only updating the context. For cases like this, Fini allows you to simply just return the updated context object directly, instead of explicitly specifying what state we're in:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: (machine, payload) => ({\n        ...machine.context,\n        email: payload,\n      }),\n    },\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"Let's add the ",Object(s.b)("inlineCode",{parentName:"p"},"changePassword")," event handler as well (and make things a bit more readably, while we're at it):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: ({ context }, email) => ({\n        ...context,\n        email,\n      }),\n      changePassword: ({ context }, password) => ({\n        ...context,\n        password,\n      }),\n    },\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"Let's also quickly hook it up with some input fields so we can see how interacting with the machine works:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(...)\n\n  return <div>\n    <input\n      value={loginMachine.context.email}\n      onChange={event => loginMachine.changeEmail(event.target.value)}\n    />\n    <input\n      value={loginMachine.context.password}\n      onChange={event => loginMachine.changePassword(event.target.value)}\n    />\n  </div>\n}\n")),Object(s.b)("p",null,"Now, I know what you're probably thinking: ",Object(s.b)("em",{parentName:"p"},"all this code for a couple of inputs?! \ud83e\udd2f")),Object(s.b)("p",null,"And you would be right for thinking it. However, now that we have covered the basics from schema to implementation, we're getting ready to finish the rest of our schema, and hopefully start showing the parts where all this typing pays off!"),Object(s.b)("h2",{id:"states-and-side-effects"},"States and side-effects"),Object(s.b)("p",null,"Moving on, we'll add support for attempting to log in."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type User = {\n  id: string;\n  name: string;\n};\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n      submit: never;\n    }>;\n    submitting: State<{\n      success: User;\n    }>;\n  },\n  { email: string; password: string }\n>;\n")),Object(s.b)("p",null,"Note that ",Object(s.b)("inlineCode",{parentName:"p"},"submit")," has a payload type of ",Object(s.b)("inlineCode",{parentName:"p"},"never"),"! This is because it literally never accepts a payload, since ",Object(s.b)("inlineCode",{parentName:"p"},"email")," and ",Object(s.b)("inlineCode",{parentName:"p"},"password")," is already available through the machine's context."),Object(s.b)("p",null,"We have also added a second state. How exciting! We'll head right over to our implementation and attempt to make a transition."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(\n    {\n      input: {\n        changeEmail: ({ context }, email) => ({\n          ...context,\n          email,\n        }),\n        changePassword: ({ context }, password) => ({\n          ...context,\n          password,\n        }),\n        submit: "submitting",\n      },\n      submitting: {\n        success: () => {}, // TODO\n      },\n    },\n    {\n      state: "input",\n      context: {\n        email: "",\n        password: "",\n      },\n    }\n  );\n\n  return (\n    <div>\n      <input\n        value={loginMachine.context.email}\n        onChange={(event) => loginMachine.changeEmail(event.target.value)}\n      />\n      <input\n        value={loginMachine.context.password}\n        onChange={(event) => loginMachine.changePassword(event.target.value)}\n      />\n      <button onClick={loginMachine.submit}>Submit</button>\n    </div>\n  );\n};\n')),Object(s.b)("p",null,"There are a couple of new things to go over here. First of all, we're using a string shorthand to define the next state for our machine. This is handy when there aren't any context updates required for the event. Secondly, we've added the (for now empty) ",Object(s.b)("inlineCode",{parentName:"p"},"submitting")," state. And finally, we've added a simple button to dispatch the event for us."),Object(s.b)("p",null,"You might however notice that something is missing: we're not actually doing any requests to the server! Let's go right ahead and create our first ",Object(s.b)("em",{parentName:"p"},"side-effect")," \ud83d\udcaf"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: ({ context }, email) => ({\n        ...context,\n        email,\n      }),\n      changePassword: ({ context }, password) => ({\n        ...context,\n        password,\n      }),\n      submit: ({ context, exec }) => {\n        exec(() => {\n          fetch("/api/login", {\n            method: "POST",\n            body: JSON.stringify(context),\n          })\n            .then((res) => res.json())\n            .then((user: User) => dispatch.success(user));\n        });\n        return "submitting";\n      },\n    },\n    submitting: {\n      success: () => {}, // TODO\n    },\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"Alongside ",Object(s.b)("inlineCode",{parentName:"p"},"context"),", all event handlers have an ",Object(s.b)("inlineCode",{parentName:"p"},"exec")," function at their disposal. Simply put, ",Object(s.b)("inlineCode",{parentName:"p"},"exec")," is just a function that is set up to call whatever function we put inside it when the next state update happens."),Object(s.b)("p",null,"In our case, we've given it a simple function that will make a request to our endpoint, and when it resolves, it will dispatch the ",Object(s.b)("inlineCode",{parentName:"p"},"success")," event. Now we're getting somewhere!"),Object(s.b)("p",null,"(For simplicity, we're assuming the request will never fail, which you probably shouldn't do in real life. Please don't use this example in production.)"),Object(s.b)("p",null,"Let's set ourselves up for success, and create a transition to the ",Object(s.b)("inlineCode",{parentName:"p"},"loggedIn")," state:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'type User = {\n  id: string;\n  name: string;\n};\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n      submit: never;\n    }>;\n    submitting: State<{\n      success: User;\n    }>;\n    loggedIn: State<{\n      logOut: never\n    }, { user: User }>\n  },\n  { email: string; password: string }\n>;\n\n...\n\nconst loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: ({ context }, email) => ({\n        ...context,\n        email,\n      }),\n      changePassword: ({ context }, password) => ({\n        ...context,\n        password,\n      }),\n      submit: ({ context, exec }) => {\n        exec(() => {\n            fetch("/api/login", {\n              method: "POST",\n              body: JSON.stringify(context)\n            })\n              .then((res) => res.json())\n              .then((user: User) => dispatch.success(user));\n          });\n        return "submitting";\n      },\n    },\n    submitting: {\n      success: ({ context }, user) => ({\n        state: "loggedIn",\n        context: {\n          ...context,\n          user\n        }\n      }),\n    },\n    loggedIn: {\n      logOut: {\n        state: "input",\n        context: {\n          email: "",\n          password: ""\n        }\n      }\n    }\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(s.b)("p",null,"There's a couple of things going on here. Let's talk about the ",Object(s.b)("em",{parentName:"p"},"implementation")," of the ",Object(s.b)("inlineCode",{parentName:"p"},"loggedIn")," state first. Immediately, you might notice another shorthand syntax for defining the next state. That is, simply declaring an object directly on the event, instead of returning it from a function. Neat!"),Object(s.b)("p",null,"Then there's the schema definition. This is a prime example of state-specific context: the ",Object(s.b)("inlineCode",{parentName:"p"},"user")," object is only available if we're in the ",Object(s.b)("inlineCode",{parentName:"p"},"loggedIn")," state, and Fini allows us to model that with ease! If we're attempting to access ",Object(s.b)("inlineCode",{parentName:"p"},"loginMachine.context.user")," without checking that we're in the ",Object(s.b)("inlineCode",{parentName:"p"},"loggedIn")," state first, TypeScript will do all kinds of yelling at us. Instead, let's have a look at how we can show and hide the correct parts of our UI based on the state."),Object(s.b)("p",null,"Fini gives us a couple of ways to check the current state. The first one is using the ",Object(s.b)("inlineCode",{parentName:"p"},"loginMachine.current")," property, which can be any of the state names. In our case that would be ",Object(s.b)("inlineCode",{parentName:"p"},'"input" | "submitting" | "loggedIn"'),", so a check would look like this: ",Object(s.b)("inlineCode",{parentName:"p"},'loginMachine.current === "loggedIn"'),"."),Object(s.b)("p",null,"The second way is simply doing ",Object(s.b)("inlineCode",{parentName:"p"},"loginMachine.loggedIn"),", which returns ",Object(s.b)("inlineCode",{parentName:"p"},"true"),"/",Object(s.b)("inlineCode",{parentName:"p"},"false")," depending on whether the state is active."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(...);\n\n  return (\n    <div>\n      {\n        loginMachine.input && <div>\n          <input\n            value={loginMachine.context.email}\n            onChange={event => loginMachine.changeEmail(event.target.value)}\n          />\n          <input\n            value={loginMachine.context.password}\n            onChange={event => loginMachine.changePassword(event.target.value)}\n          />\n          <button onClick={loginMachine.submit}>Submit</button>\n        </div>\n      }\n      { loginMachine.current === "submitting" && <p>Loading user...</p> }\n      {\n        loginMachine.loggedIn && <div>\n          <p>Welcome, {loginMachine.context.user.name}!</p>\n          <button onClick={loginMachine.logOut}>Log out</button>\n        </div>\n      }\n    </div>\n  );\n};\n')),Object(s.b)("h2",{id:"finished-result"},"Finished result"),Object(s.b)("p",null,"Finally, the component in its entirety (",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://codesandbox.io/s/fini-loginmachine-4ut16"}),"CodeSandbox"),"):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import { Machine, State, useMachine } from "fini";\n\ntype User = {\n  id: string;\n  name: string;\n};\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n      submit: never;\n    }>;\n    submitting: State<{\n      success: User;\n    }>;\n    loggedIn: State<\n      {\n        logOut: never;\n      },\n      { user: User }\n    >;\n  },\n  { email: string; password: string }\n>;\n\nconst LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(\n    {\n      input: {\n        changeEmail: ({ context }, email) => ({\n          ...context,\n          email,\n        }),\n        changePassword: ({ context }, password) => ({\n          ...context,\n          password,\n        }),\n        submit: ({ context, exec }) => {\n          exec(() => {\n            fetch("/api/login", {\n              method: "POST",\n              body: JSON.stringify(context),\n            })\n              .then((res) => res.json())\n              .then((user: User) => dispatch.success(user));\n          });\n          return "submitting";\n        },\n      },\n      submitting: {\n        success: ({ context }, user) => ({\n          state: "loggedIn",\n          context: {\n            ...context,\n            user,\n          },\n        }),\n      },\n      loggedIn: {\n        logOut: {\n          state: "input",\n          context: {\n            email: "",\n            password: "",\n          },\n        },\n      },\n    },\n    {\n      state: "input",\n      context: {\n        email: "",\n        password: "",\n      },\n    }\n  );\n\n  return (\n    <div>\n      {loginMachine.input && (\n        <div>\n          <input\n            value={loginMachine.context.email}\n            onChange={(event) => loginMachine.changeEmail(event.target.value)}\n          />\n          <input\n            value={loginMachine.context.password}\n            onChange={(event) =>\n              loginMachine.changePassword(event.target.value)\n            }\n          />\n          <button onClick={loginMachine.submit}>Submit</button>\n        </div>\n      )}\n      {loginMachine.current === "submitting" && <p>Loading user...</p>}\n      {loginMachine.loggedIn && (\n        <div>\n          <p>Welcome, {loginMachine.context.user.name}!</p>\n          <button onClick={loginMachine.logOut}>Log out</button>\n        </div>\n      )}\n    </div>\n  );\n};\n')),Object(s.b)("hr",null),Object(s.b)("h2",{id:"admonitions"},"Admonitions"),Object(s.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"This is a note"))),Object(s.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"This is a tip"))),Object(s.b)("div",{className:"admonition admonition-important alert alert--info"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"important")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"This is important"))),Object(s.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"This is a caution"))),Object(s.b)("div",{className:"admonition admonition-warning alert alert--danger"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"This is a warning"))))}p.isMDXComponent=!0}}]);