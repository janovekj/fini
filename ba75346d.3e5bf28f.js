(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{72:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return r})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var a=t(2),i=t(6),o=(t(0),t(76)),s={title:"States and side-effects"},r={unversionedId:"step-by-step/states-and-side-effects",id:"step-by-step/states-and-side-effects",isDocsHomePage:!1,title:"States and side-effects",description:"Moving on, we'll add support for attempting to log in.",source:"@site/docs/step-by-step/states-and-side-effects.md",slug:"/step-by-step/states-and-side-effects",permalink:"/step-by-step/states-and-side-effects",editUrl:"https://github.com/janovekj/fini/edit/gh-pages/website/docs/step-by-step/states-and-side-effects.md",version:"current",sidebar:"docs",previous:{title:"Implementing a basic machine",permalink:"/step-by-step/implementing-a-basic-machine"},next:{title:"Finished result",permalink:"/step-by-step/finished-result"}},c=[],l={rightToc:c};function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Moving on, we'll add support for attempting to log in."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"type User = {\n  id: string;\n  name: string;\n};\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n      submit: never;\n    }>;\n    submitting: State<{\n      success: User;\n    }>;\n  },\n  { email: string; password: string }\n>;\n")),Object(o.b)("p",null,"Note that ",Object(o.b)("inlineCode",{parentName:"p"},"submit")," has a payload type of ",Object(o.b)("inlineCode",{parentName:"p"},"never"),"! This is because it literally never accepts a payload, since ",Object(o.b)("inlineCode",{parentName:"p"},"email")," and ",Object(o.b)("inlineCode",{parentName:"p"},"password")," is already available through the machine's context."),Object(o.b)("p",null,"We have also added a second state. How exciting! We'll head right over to our implementation and attempt to make a transition."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(\n    {\n      input: {\n        changeEmail: ({ context }, email) => ({\n          ...context,\n          email,\n        }),\n        changePassword: ({ context }, password) => ({\n          ...context,\n          password,\n        }),\n        submit: "submitting",\n      },\n      submitting: {\n        success: () => {}, // TODO\n      },\n    },\n    {\n      state: "input",\n      context: {\n        email: "",\n        password: "",\n      },\n    }\n  );\n\n  return (\n    <div>\n      <input\n        value={loginMachine.context.email}\n        onChange={(event) => loginMachine.changeEmail(event.target.value)}\n      />\n      <input\n        value={loginMachine.context.password}\n        onChange={(event) => loginMachine.changePassword(event.target.value)}\n      />\n      <button onClick={loginMachine.submit}>Submit</button>\n    </div>\n  );\n};\n')),Object(o.b)("p",null,"There are a couple of new things to go over here. First of all, we're using a string shorthand to define the next state for our machine. This is handy when there aren't any context updates required for the event. Secondly, we've added the (for now empty) ",Object(o.b)("inlineCode",{parentName:"p"},"submitting")," state. And finally, we've added a simple button to dispatch the event for us."),Object(o.b)("p",null,"You might however notice that something is missing: we're not actually doing any requests to the server! Let's go right ahead and create our first ",Object(o.b)("em",{parentName:"p"},"side-effect")," \ud83d\udcaf"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: ({ context }, email) => ({\n        ...context,\n        email,\n      }),\n      changePassword: ({ context }, password) => ({\n        ...context,\n        password,\n      }),\n      submit: ({ context, exec }) => {\n        exec(() => {\n          fetch("/api/login", {\n            method: "POST",\n            body: JSON.stringify(context),\n          })\n            .then((res) => res.json())\n            .then((user: User) => dispatch.success(user));\n        });\n        return "submitting";\n      },\n    },\n    submitting: {\n      success: () => {}, // TODO\n    },\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(o.b)("p",null,"Alongside ",Object(o.b)("inlineCode",{parentName:"p"},"context"),", all event handlers have an ",Object(o.b)("inlineCode",{parentName:"p"},"exec")," function at their disposal. Simply put, ",Object(o.b)("inlineCode",{parentName:"p"},"exec")," is just a function that is set up to call whatever function we put inside it when the next state update happens."),Object(o.b)("p",null,"In our case, we've given it a simple function that will make a request to our endpoint, and when it resolves, it will dispatch the ",Object(o.b)("inlineCode",{parentName:"p"},"success")," event. Now we're getting somewhere!"),Object(o.b)("p",null,"(For simplicity, we're assuming the request will never fail, which you probably shouldn't do in real life. Please don't use this example in production.)"),Object(o.b)("p",null,"Let's set ourselves up for success, and create a transition to the ",Object(o.b)("inlineCode",{parentName:"p"},"loggedIn")," state:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'type User = {\n  id: string;\n  name: string;\n};\n\ntype LoginMachine = Machine<\n  {\n    input: State<{\n      changeEmail: string;\n      changePassword: string;\n      submit: never;\n    }>;\n    submitting: State<{\n      success: User;\n    }>;\n    loggedIn: State<{\n      logOut: never\n    }, { user: User }>\n  },\n  { email: string; password: string }\n>;\n\n...\n\nconst loginMachine = useMachine<LoginMachine>(\n  {\n    input: {\n      changeEmail: ({ context }, email) => ({\n        ...context,\n        email,\n      }),\n      changePassword: ({ context }, password) => ({\n        ...context,\n        password,\n      }),\n      submit: ({ context, exec }) => {\n        exec(() => {\n            fetch("/api/login", {\n              method: "POST",\n              body: JSON.stringify(context)\n            })\n              .then((res) => res.json())\n              .then((user: User) => dispatch.success(user));\n          });\n        return "submitting";\n      },\n    },\n    submitting: {\n      success: ({ context }, user) => ({\n        state: "loggedIn",\n        context: {\n          ...context,\n          user\n        }\n      }),\n    },\n    loggedIn: {\n      logOut: {\n        state: "input",\n        context: {\n          email: "",\n          password: ""\n        }\n      }\n    }\n  },\n  {\n    state: "input",\n    context: {\n      email: "",\n      password: "",\n    },\n  }\n);\n')),Object(o.b)("p",null,"There's a couple of things going on here. Let's talk about the ",Object(o.b)("em",{parentName:"p"},"implementation")," of the ",Object(o.b)("inlineCode",{parentName:"p"},"loggedIn")," state first. Immediately, you might notice another shorthand syntax for defining the next state. That is, simply declaring an object directly on the event, instead of returning it from a function. Neat!"),Object(o.b)("p",null,"Then there's the schema definition. This is a prime example of state-specific context: the ",Object(o.b)("inlineCode",{parentName:"p"},"user")," object is only available if we're in the ",Object(o.b)("inlineCode",{parentName:"p"},"loggedIn")," state, and Fini allows us to model that with ease! If we're attempting to access ",Object(o.b)("inlineCode",{parentName:"p"},"loginMachine.context.user")," without checking that we're in the ",Object(o.b)("inlineCode",{parentName:"p"},"loggedIn")," state first, TypeScript will do all kinds of yelling at us. Instead, let's have a look at how we can show and hide the correct parts of our UI based on the state."),Object(o.b)("p",null,"Fini gives us a couple of ways to check the current state. The first one is using the ",Object(o.b)("inlineCode",{parentName:"p"},"loginMachine.current")," property, which can be any of the state names. In our case that would be ",Object(o.b)("inlineCode",{parentName:"p"},'"input" | "submitting" | "loggedIn"'),", so a check would look like this: ",Object(o.b)("inlineCode",{parentName:"p"},'loginMachine.current === "loggedIn"'),"."),Object(o.b)("p",null,"The second way is simply doing ",Object(o.b)("inlineCode",{parentName:"p"},"loginMachine.loggedIn"),", which returns ",Object(o.b)("inlineCode",{parentName:"p"},"true"),"/",Object(o.b)("inlineCode",{parentName:"p"},"false")," depending on whether the state is active."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'const LoginComponent = () => {\n  const loginMachine = useMachine<LoginMachine>(...);\n\n  return (\n    <div>\n      {\n        loginMachine.input && <div>\n          <input\n            value={loginMachine.context.email}\n            onChange={event => loginMachine.changeEmail(event.target.value)}\n          />\n          <input\n            value={loginMachine.context.password}\n            onChange={event => loginMachine.changePassword(event.target.value)}\n          />\n          <button onClick={loginMachine.submit}>Submit</button>\n        </div>\n      }\n      { loginMachine.current === "submitting" && <p>Loading user...</p> }\n      {\n        loginMachine.loggedIn && <div>\n          <p>Welcome, {loginMachine.context.user.name}!</p>\n          <button onClick={loginMachine.logOut}>Log out</button>\n        </div>\n      }\n    </div>\n  );\n};\n')))}p.isMDXComponent=!0},76:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return g}));var a=t(0),i=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),p=function(e){var n=i.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return i.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(t),b=a,g=u["".concat(s,".").concat(b)]||u[b]||d[b]||o;return t?i.a.createElement(g,r(r({ref:n},l),{},{components:t})):i.a.createElement(g,r({ref:n},l))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=b;var r={};for(var c in n)hasOwnProperty.call(n,c)&&(r[c]=n[c]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var l=2;l<o;l++)s[l]=t[l];return i.a.createElement.apply(null,s)}return i.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);